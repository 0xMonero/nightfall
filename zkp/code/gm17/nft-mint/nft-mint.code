import "hashes/sha256/1024bit.code" as sha256of1024
import "hashes/sha256/512bit.code" as sha256of512
import "utils/pack/unpack128.code" as unpack128

def concatenate256x256x256(field[256] a, field[256] b, field[256] c)->(field[768]):
	return [...a, ...b, ...c]

// Provides the padding (only!) for a 768-bit message.
def shaPad768To1024()->(field[256]):
	return [1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	1,	0,	0,	0,	0,	0,	0,	0,	0]


//inputs for main are:
// Proving Asset Token 'asset' is in the commitment { commitment= H(asset|publicKey|salt) }
// - salt (private) is the salt for the commitment
// - publicKey (private) is the public key of Alice derived by hashing the secretKey of Alice
// - commitment - is the public commitment
// - asset - is the ERC-721 tokenId for the asset

// Note - We truncate the 256 bit SHA hash down to 216 bits to make the code shorter. This will have an effect on security but not for any practical purpose we believe.

//Each field element passed to main() can be at most 128bits, to make use of unpack128()


def main(field  assetHigh, field  assetLow, private field  publicKeyHigh, private field  publicKeyLow, private field  saltHigh, private field  saltLow, field  commitmentHigh, field  commitmentLow)->(field):


	// Unpack the inputs of main() to 128 bits. We'll unpack each field to its own 128 bit string for simplicity for now. Later efficiencies could be made by grouping some inputs.

	field[128] assetHighBits = unpack128(assetHigh)
	field[128] assetLowBits = unpack128(assetLow)
	field[256] assetBits = [...assetHighBits, ...assetLowBits]

	field[128] saltHighBits = unpack128(saltHigh)
	field[128] saltLowBits = unpack128(saltLow)
	field[256] saltBits = [...saltHighBits, ...saltLowBits]

	field[128] publicKeyHighBits = unpack128(publicKeyHigh)
	field[128] publicKeyLowBits = unpack128(publicKeyLow)
	field[256] publicKeyBits = [...publicKeyHighBits, ...publicKeyLowBits]

	field[128] commitmentHighBits = unpack128(commitmentHigh)
	field[128] commitmentLowBits = unpack128(commitmentLow)
	field[256] commitmentBits = [...commitmentHighBits, ...commitmentLowBits]


	field[256] padding768To1024 = shaPad768To1024()


	// Compute commitment = H(asset|publicKey|salt):
	field[768] preimage768 = concatenate256x256x256(assetBits, publicKeyBits, saltBits)

	field[256] commitmentBitsCheck = sha256of1024(preimage768[0..256], preimage768[256..512], preimage768[512..768], padding768To1024)


	// This checks if the hash commitmentBitsCheck we computed using 'asset' (which is H(asset|publicKey|salt)) is equal to the input commitment:
	commitmentBits == commitmentBitsCheck


	return 1
